<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>Quebra-cabe√ßa do Oceano - Arraial do Cabo</title>

    <!-- Favicon inline SVG -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='0.9em' font-size='90'>üß©</text></svg>">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            overflow-x: hidden; /* Allow vertical scrolling when needed */
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(180deg, #1e3c72 0%, #2a5298 50%, #7db9e8 100%);
            padding: 10px;
            position: relative;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        /* Bolhas de fundo animadas */
        .bubble {
            position: absolute;
            bottom: -100px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            animation: rise 15s infinite ease-in;
            pointer-events: none;
            z-index: 0;
        }

        @keyframes rise {
            to {
                bottom: 100vh;
                transform: translateX(100px);
                opacity: 0;
            }
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
            width: 100%;
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
        }

        header {
            text-align: center;
            color: white;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            flex-shrink: 0;
        }

        header h1 {
            font-size: 2em;
            margin-bottom: 3px;
            animation: fadeInDown 0.8s ease;
        }

        header p {
            font-size: 1em;
            opacity: 0.9;
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: transparent;
            padding: 10px 12px;
            border-radius: 12px;
            margin-bottom: 10px;
            flex-shrink: 0;
        }

        .top-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .top-btn {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.9em;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0,131,143,0.3);
        }

        /* Hide game control buttons on difficulty selection screen */
        #menuScreen ~ .game-info .top-btn {
            display: none;
        }

        .top-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,188,212,0.4);
            background: linear-gradient(135deg, #2980b9, #1f618d);
        }

        .score {
            font-weight: bold;
            color: #2c3e50;
        }

        .back-button {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .back-button:hover {
            background: #c0392b;
            transform: translateY(-2px);
        }

        .game-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 15px;
            overflow: hidden;
        }

        .menu-screen {
            text-align: center;
            padding: 20px;
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .menu-title {
            font-size: 2.5em;
            color: #2c3e50;
            margin-bottom: 30px;
            font-weight: bold;
        }

        .difficulty-buttons {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .difficulty-btn {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .difficulty-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .difficulty-btn.easy {
            background: linear-gradient(135deg, #27ae60, #229954);
        }

        .difficulty-btn.medium {
            background: linear-gradient(135deg, #f39c12, #e67e22);
        }

        .difficulty-btn.hard {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
        }

        .game-screen {
            display: none;
            flex: 1;
            flex-direction: column;
        }

        .puzzle-container {
            flex: 1;
            display: flex;
            gap: 6px; /* Consistent gap size */
            margin-bottom: 15px;
            min-height: 400px; /* Allow JavaScript to control exact height */
            align-items: stretch;
            overflow: hidden; /* Prevent content overflow */
        }

        .puzzle-board {
            flex: 1;
            position: relative;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #2980b9;
            border-radius: 15px;
            display: grid;
            padding: 15px;
            margin: 0 auto;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            gap: 6px;
            overflow: hidden; /* Prevent pieces from escaping */
        }

        .pieces-area {
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid #3498db;
            border-radius: 15px;
            padding: 15px;
            overflow: hidden;
            display: grid;
            gap: 6px;
            align-items: center;
            justify-items: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            flex: 1; /* Equal share with puzzle-board for 50/50 split */
        }

        .puzzle-piece {
            position: relative;
            cursor: grab;
            transition: all 0.3s ease;
            border: 3px solid #2c3e50;
            border-radius: 6px;
            box-shadow: 0 6px 20px rgba(0,0,0,0.4);
            background: white;
            margin: 0 auto;
            align-self: center;
        }

        .puzzle-piece:hover {
            transform: scale(1.03);
            z-index: 10;
            border-color: #3498db;
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
        }

        .puzzle-piece.dragging {
            cursor: grabbing;
            opacity: 0.9;
            z-index: 1000;
            transform: scale(1.1);
            border-color: #e74c3c;
            box-shadow: 0 8px 25px rgba(231, 76, 60, 0.4);
            transition: none;
        }

        .puzzle-slot {
            background: #f8f9fa;
            border: 2px dashed #6c757d;
            border-radius: 8px;
            position: relative;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .puzzle-slot::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.3));
            border-radius: 6px;
            pointer-events: none;
        }

        .puzzle-slot:hover {
            background: #e9ecef;
            border-color: #3498db;
            border-style: solid;
            transform: scale(1.02);
        }

        .puzzle-slot.drag-over {
            background: #d1ecf1;
            border-color: #0c5460;
            border-style: solid;
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(13, 110, 253, 0.3);
        }

        .puzzle-slot.filled {
            border: none;
            background: transparent;
        }

        .puzzle-slot.filled::before {
            display: none;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 10px;
        }

        .control-btn {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            font-size: 0.95em;
        }

        .control-btn:hover {
            background: linear-gradient(135deg, #2980b9, #1f618d);
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0,0,0,0.3);
        }

        .complete-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            max-width: 500px;
            animation: slideIn 0.5s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: scale(0.8);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .modal-title {
            font-size: 2em;
            color: #27ae60;
            margin-bottom: 20px;
        }

        .modal-text {
            font-size: 1.1em;
            color: #2c3e50;
            margin-bottom: 30px;
            line-height: 1.6;
        }

        .modal-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            header h1 {
                font-size: 1.5em;
            }

            .puzzle-container {
                flex-direction: column;
                gap: 20px;
                height: auto;
                align-items: center;
            }

            .puzzle-board {
                width: 100%;
                max-width: none;
                padding: 12px;
                gap: 4px;
                justify-self: center;
            }

            .pieces-area {
                width: 100%;
                max-width: none;
                min-height: 150px;
                overflow: hidden;
                padding: 12px;
                gap: 4px;
                justify-self: center;
            }

            .puzzle-piece {
                max-width: 200px; /* Increased from 110px for better mobile experience */
                max-height: 200px;
                border-width: 2px;
                box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            }

            .game-info {
                flex-direction: column;
                gap: 10px;
                align-items: center; /* Center align on mobile */
            }

            .top-controls {
                flex-wrap: wrap;
                justify-content: center;
                max-width: 100%;
            }

            .top-btn {
                min-height: 44px; /* Touch-friendly */
                font-size: 0.85em;
                padding: 10px 14px;
            }

            .difficulty-buttons {
                flex-direction: column;
                width: 100%;
                max-width: 280px;
            }

            .difficulty-btn {
                width: 100%;
                padding: 18px 25px;
                font-size: 1.1em;
            }

            .controls {
                flex-wrap: wrap;
                gap: 10px;
            }

            .control-btn {
                font-size: 0.9em;
                padding: 10px 18px;
            }
        }

        @media (max-width: 480px) {
            body {
                padding: 5px;
            }

            header h1 {
                font-size: 1.3em;
            }

            header p {
                font-size: 0.9em;
            }

            .game-area {
                padding: 10px;
            }

            .puzzle-board {
                width: 100%;
                max-width: none;
                padding: 10px;
                gap: 3px;
                justify-self: center;
            }

            .pieces-area {
                width: 100%;
                max-width: none;
                min-height: 120px;
                overflow: hidden;
                padding: 10px;
                gap: 3px;
                justify-self: center;
            }

            .puzzle-piece {
                max-width: 160px; /* Increased from 90px for better mobile experience */
                max-height: 160px;
                border-width: 2px;
                box-shadow: 0 3px 12px rgba(0,0,0,0.25);
            }

            .modal-content {
                padding: 20px;
                margin: 20px;
            }

            .controls {
                flex-direction: column;
            }

            .control-btn {
                width: 100%;
                padding: 12px 20px;
            }

            .menu-title {
                font-size: 2em;
            }

            .difficulty-btn {
                padding: 15px 20px;
                font-size: 1em;
            }
        }

        /* Large screens - optimize layout */
        @media (min-width: 1200px) {
            .puzzle-container {
                max-width: 1400px; /* Increased for larger puzzle pieces */
                margin: 0 auto;
                max-height: 85vh; /* Increased height for easy difficulty */
                overflow: hidden; /* Ensure contents stay within bounds */
            }

            .puzzle-board {
                flex: 1; /* Equal flex distribution */
                min-width: 0; /* Allow shrinking */
                overflow: hidden; /* Prevent pieces from escaping */
            }

            .pieces-area {
                flex: 1; /* Equal flex distribution */
                min-width: 0; /* Allow shrinking */
                overflow: hidden; /* Prevent pieces from escaping */
            }

            .puzzle-piece {
                box-shadow: 0 8px 25px rgba(0,0,0,0.5);
            }
        }

        /* Responsive gap for desktop */
        @media (max-width: 900px) {
            .puzzle-container {
                gap: 6px; /* Consistent gap size */
            }
        }

        /* Extra small mobile improvements */
        @media (max-width: 360px) {
            .container {
                padding: 5px;
            }

            header h1 {
                font-size: 1.2em;
            }

            header p {
                font-size: 0.8em;
            }

            .game-info {
                flex-direction: column;
                gap: 8px;
                padding: 8px 10px;
                align-items: center;
            }

            .score {
                font-size: 0.9em;
            }

            .top-controls {
                flex-wrap: wrap;
                justify-content: center;
            }

            .top-btn {
                min-height: 44px;
                font-size: 0.8em;
                padding: 8px 12px;
            }

            .back-button {
                padding: 10px 15px;
                font-size: 0.9em;
                min-height: 44px; /* Touch-friendly minimum */
            }

            .difficulty-btn {
                min-height: 44px; /* Touch-friendly minimum */
                padding: 20px 15px;
                font-size: 1em;
            }

            .control-btn {
                min-height: 44px; /* Touch-friendly minimum */
                padding: 15px 20px;
                font-size: 0.9em;
                margin: 5px 0;
            }

            .puzzle-container {
                gap: 15px;
            }

            .puzzle-board, .pieces-area {
                padding: 8px;
                gap: 2px;
            }

            .modal-content {
                padding: 15px;
                margin: 10px;
                max-width: 95%;
            }

            .modal-title {
                font-size: 1.5em;
            }

            .modal-text {
                font-size: 0.9em;
            }
        }

        /* Touch-friendly improvements for all mobile devices */
        @media (hover: none) and (pointer: coarse) {
            .puzzle-piece {
                min-width: 44px;
                min-height: 44px;
            }

            .puzzle-slot {
                min-width: 44px;
                min-height: 44px;
            }

            .control-btn, .difficulty-btn, .back-button {
                min-height: 44px;
                font-size: 16px; /* Prevent iOS zoom */
            }

            /* Improve touch feedback */
            .puzzle-piece:hover {
                transform: scale(1.05);
            }

            .puzzle-slot:hover {
                transform: scale(1.02);
            }
        }
    </style>
</head>
<body>
    <!-- Animated bubbles background -->
    <div class="bubble" style="width: 60px; height: 60px; left: 10%; animation-delay: 0s;"></div>
    <div class="bubble" style="width: 40px; height: 40px; left: 25%; animation-delay: 3s;"></div>
    <div class="bubble" style="width: 80px; height: 80px; left: 50%; animation-delay: 6s;"></div>
    <div class="bubble" style="width: 50px; height: 50px; left: 70%; animation-delay: 2s;"></div>
    <div class="bubble" style="width: 70px; height: 70px; left: 85%; animation-delay: 5s;"></div>
    <div class="bubble" style="width: 45px; height: 45px; left: 15%; animation-delay: 8s;"></div>
    <div class="bubble" style="width: 65px; height: 65px; left: 90%; animation-delay: 1s;"></div>

    <div class="container">
        <header>
            <h1>üß© Quebra-cabe√ßa do Oceano</h1>
            <p>Monte ecossistemas marinhos de Arraial do Cabo</p>
        </header>

        <div class="game-info">
<!--            <div class="score">Pontos: <span id="score">0</span></div>-->
            <div class="top-controls">
<!--                <button class="top-btn" onclick="showHint()">üí° Dica</button>-->
<!--                <button class="top-btn" onclick="shufflePieces()">üîÄ Embaralhar</button>-->
                <button class="back-button" onclick="backToMenu()">‚Üê Voltar</button>
            </div>
        </div>

        <div class="game-area">
            <!-- Menu de sele√ß√£o de dificuldade -->
            <div class="menu-screen" id="menuScreen">
                <div class="menu-title">üåä Escolha a Dificuldade</div>
                <div class="difficulty-buttons">
                    <button class="difficulty-btn easy" onclick="startGame('easy')">
                        üü¢ F√°cil<br>6 pe√ßas
                    </button>
                    <button class="difficulty-btn medium" onclick="startGame('medium')">
                        üü° M√©dio<br>9 pe√ßas
                    </button>
                    <button class="difficulty-btn hard" onclick="startGame('hard')">
                        üî¥ Dif√≠cil<br>16 pe√ßas
                    </button>
                </div>
                <p style="color: #2c3e50; margin-top: 20px; text-align: center; max-width: 400px;">
                    Arraste e solte as pe√ßas para montar as imagens dos ecossistemas marinhos.
                    Descubra a diferen√ßa entre oceanos saud√°veis e degradados!
                </p>
            </div>

            <!-- √Årea do jogo -->
            <div class="game-screen" id="gameScreen">
                <div class="game-info">
                    <div class="score">Pontos: <span id="score">0</span></div>
                    <div class="top-controls">
                        <button class="top-btn" onclick="showHint()">üí° Dica</button>
                        <button class="top-btn" onclick="shufflePieces()">üîÄ Embaralhar</button>
                    </div>
                </div>
                <div class="puzzle-container">
                    <div class="pieces-area" id="piecesArea"></div>
                    <div class="puzzle-board" id="puzzleBoard"></div>
                </div>
                <!-- Comparar button removed - healthy/degraded are sequential -->
            </div>
        </div>
    </div>

    <!-- Modal de conclus√£o -->
    <div class="complete-modal" id="completeModal">
        <div class="modal-content">
            <div class="modal-title">üéâ Parab√©ns!</div>
            <div class="modal-text" id="modalText">
                Voc√™ completou o quebra-cabe√ßa com sucesso!
            </div>
            <div class="modal-buttons" id="modalButtons">
                <button class="control-btn" onclick="nextPuzzle()">Pr√≥ximo</button>
                <button class="control-btn" onclick="backToMenu()">Menu</button>
            </div>
        </div>
    </div>

    <script>
        // Game state
        let gameState = {
            currentDifficulty: null,
            currentImageIndex: 0,
            score: 0,
            isGameComplete: false,
            pieces: [],
            slots: [],
            completedSlots: 0,
            draggedPiece: null
        };

        // Sequential image data - exact requested order
        const imageSequence = [
            { src: 'img/01-healthy.png', type: 'healthy', ecosystem: 'Recife de Coral',
              title: 'Ecossistema Saud√°vel!',
              text: 'Este √© um oceano saud√°vel de Arraial do Cabo! Os corais est√£o vibrantes, os peixes nadam livremente e a √°gua est√° limpa. A biodiversidade marinha √© essencial para o equil√≠brio do nosso planeta.' },

            { src: 'img/01-degraded.png', type: 'degraded', ecosystem: 'Recife de Coral',
              title: 'Ecossistema Amea√ßado!',
              text: 'Este ecossistema sofre com a polui√ß√£o humana. O lixo pl√°stico, o branqueamento de corais e a pesca excessiva amea√ßam a vida marinha. Precisamos agir agora para proteger nossos oceanos!' },

            { src: 'img/02-healthy.png', type: 'healthy', ecosystem: 'Vida Marinha',
              title: 'Ecossistema Saud√°vel!',
              text: 'A vida marinha saud√°vel mostra o equil√≠brio perfeito da natureza. Peixes coloridos, √°guas cristalinas e corais vibrantes formam um dos ecossistemas mais ricos do planeta!' },

            { src: 'img/02-degraded.png', type: 'degraded', ecosystem: 'Vida Marinha',
              title: 'Ecossistema Amea√ßado!',
              text: 'A polui√ß√£o amea√ßa a vida marinha! O lixo pl√°stico sufoca os animais, a pesca predat√≥ria desequilibra a cadeia alimentar e a contamina√ß√£o qu√≠mica destr√≥i os habitats naturais.' },

            { src: 'img/03-healthy.png', type: 'healthy', ecosystem: 'Oceano Aberto',
              title: 'Ecossistema Saud√°vel!',
              text: 'O oceano aberto saud√°vel √© o ber√ßo da vida! Suas √°guas azuis e puras sustentam gigantes gentis como as baleias, e milhares de esp√©cies que mant√™m nosso planeta vivo.' },

            { src: 'img/03-degraded.png', type: 'degraded', ecosystem: 'Oceano Aberto',
              title: 'Ecossistema Amea√ßado!',
              text: 'O oceano aberto est√° em perigo! Derramamentos de √≥leo, pl√°sticos microsc√≥picos e a acidifica√ß√£o dos oceanos amea√ßam eliminar esp√©cies inteiras e desequilibrar o clima global!' }
        ];

        // Helper function to generate image sequence (for future extensibility)
        function generateImageSequence() {
            const ecosystems = [
                { id: 1, name: 'Recife de Coral' },
                { id: 2, name: 'Vida Marinha' },
                { id: 3, name: 'Oceano Aberto' }
                // Add more ecosystems here in the future (4, 5, etc.)
            ];

            const sequence = [];
            ecosystems.forEach(eco => {
                sequence.push({
                    src: `img/0${eco.id}-healthy.png`,
                    type: 'healthy',
                    ecosystem: eco.name,
                    title: 'Ecossistema Saud√°vel!',
                    text: `Este √© um oceano saud√°vel de Arraial do Cabo! Os corais est√£o vibrantes, os peixes nadam livremente e a √°gua est√° limpa. A biodiversidade marinha √© essencial para o equil√≠brio do nosso planeta.`
                });
                sequence.push({
                    src: `img/0${eco.id}-degraded.png`,
                    type: 'degraded',
                    ecosystem: eco.name,
                    title: 'Ecossistema Amea√ßado!',
                    text: 'Este ecossistema sofre com a polui√ß√£o humana. O lixo pl√°stico, o branqueamento de corais e a pesca excessiva amea√ßam a vida marinha. Precisamos agir agora para proteger nossos oceanos!'
                });
            });
            return sequence;
        }

        // Difficulty configurations
        const difficultyConfig = {
            easy: { rows: 2, cols: 3, score: 100 },
            medium: { rows: 3, cols: 3, score: 200 },
            hard: { rows: 4, cols: 4, score: 300 }
        };

        // Initialize game
        function initGame() {
            updateScore();
        }

        // Start game with selected difficulty
        function startGame(difficulty) {
            gameState.currentDifficulty = difficulty;
            gameState.currentImageIndex = 0;
            gameState.isGameComplete = false;

            document.getElementById('menuScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'flex';

            loadPuzzle();
        }

        // Load puzzle
        function loadPuzzle() {
            const config = difficultyConfig[gameState.currentDifficulty];
            const currentImageData = imageSequence[gameState.currentImageIndex];
            const imagePath = currentImageData.src;

            gameState.pieces = [];
            gameState.slots = [];
            gameState.completedSlots = 0;

            const puzzleBoard = document.getElementById('puzzleBoard');
            const piecesArea = document.getElementById('piecesArea');

            // Clear previous content
            puzzleBoard.innerHTML = '';
            piecesArea.innerHTML = '';

            // Set grid layout for both areas
            puzzleBoard.style.gridTemplateColumns = `repeat(${config.cols}, 1fr)`;
            puzzleBoard.style.gridTemplateRows = `repeat(${config.rows}, 1fr)`;

            piecesArea.style.gridTemplateColumns = `repeat(${config.cols}, 1fr)`;
            piecesArea.style.gridTemplateRows = `repeat(${config.rows}, 1fr)`;

            // Create image for reference and sizing
            const img = new Image();
            img.onload = function() {
                const gapSize = 6;
                const padding = 30; // 15px cada lado
                const totalHorizontalGaps = (config.cols - 1) * gapSize;
                const totalVerticalGaps = (config.rows - 1) * gapSize;

                // Responsive piece sizing based on viewport and difficulty
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                const container = document.querySelector('.puzzle-container');
                const containerWidth = container ? container.offsetWidth : viewportWidth - 60;

                // Detect layout mode (mobile vs desktop) - simplified and reliable
                const isMobileLayout = viewportWidth <= 768;
                const isVerticalLayout = isMobileLayout; // Mobile is always vertical layout

                // Calculate available space based on layout mode
                let availableWidth;
                let containerGap;

                if (isMobileLayout) {
                    // Mobile vertical layout: use full container width minus padding
                    availableWidth = containerWidth - 60; // 30px padding each side
                    containerGap = 6; // Consistent gap size
                } else {
                    // Desktop: consistent 50/50 split across all difficulties
                    containerGap = 6; // Use consistent 6px gap to match CSS
                    availableWidth = ((containerWidth - containerGap) / 2) - 20; // Consistent padding for all difficulties
                }

                // Base piece sizes by difficulty - easy mode 4x larger for better gameplay
                let basePieceWidth, basePieceHeight;
                switch (gameState.currentDifficulty) {
                    case 'easy':
                        basePieceWidth = 960;  // 240 ‚Üí 960 (4x larger)
                        basePieceHeight = 960;
                        break;
                    case 'medium':
                        basePieceWidth = 200;  // 150 ‚Üí 200 (+33%)
                        basePieceHeight = 200;
                        break;
                    case 'hard':
                        basePieceWidth = 160;  // 120 ‚Üí 160 (+33%)
                        basePieceHeight = 160;
                        break;
                }

                // Calculate required width based on base piece size using consistent gap
                const requiredWidth = (basePieceWidth * config.cols) + ((config.cols - 1) * gapSize) + padding;

                // Apply responsive scaling if needed
                let pieceWidth, pieceHeight;
                if (requiredWidth > availableWidth) {
                    // Scale down to fit available space with precise calculation
                    let scaleFactor = availableWidth / requiredWidth;

                    // Additional scaling for easy difficulty with very large pieces
                    if (gameState.currentDifficulty === 'easy') {
                        scaleFactor = Math.min(scaleFactor, 0.8); // Limit scaling to prevent pieces from being too small
                    }

                    pieceWidth = basePieceWidth * scaleFactor;
                    pieceHeight = basePieceHeight * scaleFactor;

                    // Ensure minimum touch-friendly size
                    pieceWidth = Math.max(pieceWidth, 160);
                    pieceHeight = Math.max(pieceHeight, 160);
                } else {
                    pieceWidth = basePieceWidth;
                    pieceHeight = basePieceHeight;
                }

                // CSS flexbox now handles container sizing automatically
                // We only need to calculate piece dimensions based on available space

                // Let CSS flexbox handle container sizing automatically
                // Remove explicit width/height to allow natural 50/50 split

                // Use consistent gap across all layouts to match CSS
                const consistentGap = 6;

                // Apply consistent gap to both containers
                puzzleBoard.style.gap = consistentGap + 'px';
                piecesArea.style.gap = consistentGap + 'px';

                // Update gap calculation for final dimensions
                const finalGapSize = consistentGap;
                const finalHorizontalGaps = (config.cols - 1) * finalGapSize;
                const finalVerticalGaps = (config.rows - 1) * finalGapSize;

                // Create slots
                for (let row = 0; row < config.rows; row++) {
                    for (let col = 0; col < config.cols; col++) {
                        const slot = createSlot(row, col, pieceWidth, pieceHeight, config);
                        puzzleBoard.appendChild(slot);
                        gameState.slots.push(slot);
                    }
                }

                // Create pieces
                const pieceIndices = [];
                for (let row = 0; row < config.rows; row++) {
                    for (let col = 0; col < config.cols; col++) {
                        const index = row * config.cols + col;
                        pieceIndices.push(index);
                    }
                }

                // Create pieces in temporary array first
                const pieces = [];
                pieceIndices.forEach((originalIndex, i) => {
                    const row = Math.floor(originalIndex / config.cols);
                    const col = originalIndex % config.cols;
                    const piece = createPiece(img, row, col, originalIndex, pieceWidth, pieceHeight);
                    pieces.push(piece);
                    gameState.pieces.push(piece);
                });

                // Shuffle pieces automatically
                shuffleArray(pieces);

                // Add shuffled pieces to the pieces area
                pieces.forEach(piece => piecesArea.appendChild(piece));

                // Set up background guides for slots
                setupBackgroundGuides(img, config);
            };
            img.onerror = function() {
                console.error('Error loading image:', imagePath);
                alert('Erro ao carregar imagem. Por favor, tente novamente.');
            };
            img.src = imagePath;
        }

        // Create puzzle slot
        function createSlot(row, col, width, height, config) {
            const slot = document.createElement('div');
            slot.className = 'puzzle-slot';
            slot.dataset.row = row;
            slot.dataset.col = col;
            slot.dataset.index = row * config.cols + col;
            slot.style.width = width + 'px';
            slot.style.height = height + 'px';

            // Store position for background guide
            slot.dataset.guideRow = row;
            slot.dataset.guideCol = col;

            // Add drop event listeners
            slot.addEventListener('dragover', handleDragOver);
            slot.addEventListener('drop', handleDrop);
            slot.addEventListener('dragleave', handleDragLeave);

            return slot;
        }

        // Optimized setup background guides for slots (performance-focused)
        function setupBackgroundGuides(img, config) {
            // Use requestAnimationFrame for better performance on mobile
            requestAnimationFrame(() => {
                const sourceWidth = img.width / config.cols;
                const sourceHeight = img.height / config.rows;

                // Process slots in batches to avoid blocking UI
                const batchSize = 3; // Process 3 slots at a time
                let currentBatch = 0;

                function processBatch() {
                    const startIdx = currentBatch * batchSize;
                    const endIdx = Math.min(startIdx + batchSize, gameState.slots.length);

                    for (let i = startIdx; i < endIdx; i++) {
                        const slot = gameState.slots[i];
                        const row = parseInt(slot.dataset.guideRow);
                        const col = parseInt(slot.dataset.guideCol);
                        const slotWidth = parseInt(slot.style.width);
                        const slotHeight = parseInt(slot.style.height);

                        // Skip if slot dimensions are too small (mobile optimization)
                        if (slotWidth < 30 || slotHeight < 30) {
                            continue;
                        }

                        try {
                            // Create a canvas for the background guide
                            const guideCanvas = document.createElement('canvas');
                            guideCanvas.width = slotWidth;
                            guideCanvas.height = slotHeight;

                            const ctx = guideCanvas.getContext('2d');

                            // Use lower quality on mobile for better performance
                            const isMobile = window.innerWidth <= 768;
                            if (isMobile) {
                                ctx.imageSmoothingEnabled = false;
                            }

                            // Draw the corresponding piece section
                            const sourceX = col * sourceWidth;
                            const sourceY = row * sourceHeight;

                            ctx.drawImage(img, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, slotWidth, slotHeight);

                            // Apply filter for translucency
                            ctx.globalAlpha = 0.35;
                            ctx.fillStyle = '#f8f9fa';
                            ctx.fillRect(0, 0, slotWidth, slotHeight);

                            // Set as background image
                            slot.style.backgroundImage = `url(${guideCanvas.toDataURL('image/jpeg', 0.8)})`;
                            slot.style.backgroundSize = 'cover';
                            slot.style.backgroundPosition = 'center';
                            slot.style.backgroundRepeat = 'no-repeat';

                        } catch (error) {
                            console.warn('Error creating background guide for slot', error);
                            // Continue processing other slots even if one fails
                        }
                    }

                    currentBatch++;

                    // Process next batch if there are more slots
                    if (currentBatch * batchSize < gameState.slots.length) {
                        requestAnimationFrame(processBatch);
                    }
                }

                // Start processing batches
                processBatch();
            });
        }

        // Create puzzle piece
        function createPiece(img, row, col, index, width, height) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            canvas.className = 'puzzle-piece';
            canvas.draggable = true;
            canvas.dataset.index = index;
            canvas.dataset.correctRow = row;
            canvas.dataset.correctCol = col;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            canvas.style.border = '2px solid #34495e';
            canvas.style.borderRadius = '4px';
            canvas.style.cursor = 'grab';
            canvas.style.boxShadow = '0 2px 8px rgba(0,0,0,0.2)';

            const ctx = canvas.getContext('2d');
            const config = difficultyConfig[gameState.currentDifficulty];
            const sourceX = col * (img.width / config.cols);
            const sourceY = row * (img.height / config.rows);
            const sourceWidth = img.width / config.cols;
            const sourceHeight = img.height / config.rows;

            ctx.drawImage(img, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, width, height);

            // Add drag event listeners
            canvas.addEventListener('dragstart', handleDragStart);
            canvas.addEventListener('dragend', handleDragEnd);

            // Touch events for mobile
            canvas.addEventListener('touchstart', handleTouchStart, {passive: false});
            canvas.addEventListener('touchmove', handleTouchMove, {passive: false});
            canvas.addEventListener('touchend', handleTouchEnd, {passive: false});

            return canvas;
        }

        // Drag and drop handlers
        function handleDragStart(e) {
            gameState.draggedPiece = e.target;
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', e.target.innerHTML);
            e.target.style.zIndex = '1000';
        }

        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            e.target.style.zIndex = '';
            // Reset all slot backgrounds
            document.querySelectorAll('.puzzle-slot').forEach(slot => {
                slot.classList.remove('drag-over');
            });
            gameState.draggedPiece = null;
        }

        function handleDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';

            const slot = e.target.classList.contains('puzzle-slot') ? e.target : e.target.closest('.puzzle-slot');
            if (slot && !slot.querySelector('.puzzle-piece')) {
                slot.classList.add('drag-over');
            }
            return false;
        }

        function handleDragLeave(e) {
            const slot = e.target.classList.contains('puzzle-slot') ? e.target : e.target.closest('.puzzle-slot');
            if (slot && !slot.contains(e.relatedTarget)) {
                slot.classList.remove('drag-over');
            }
        }

        function handleDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            if (e.preventDefault) {
                e.preventDefault();
            }

            const slot = e.target.classList.contains('puzzle-slot') ? e.target : e.target.closest('.puzzle-slot');

            if (slot && gameState.draggedPiece && !slot.querySelector('.puzzle-piece')) {
                slot.classList.remove('drag-over');
                placePiece(gameState.draggedPiece, slot);
            }

            return false;
        }

        // Optimized touch event handlers for mobile
        let touchItem = null;
        let touchOffset = {x: 0, y: 0};
        let touchClone = null;
        let touchActive = false;

        function handleTouchStart(e) {
            // Prevent multiple simultaneous touches
            if (touchActive) return;

            touchActive = true;
            touchItem = e.target;

            if (!touchItem.classList.contains('puzzle-piece')) {
                touchActive = false;
                return;
            }

            const touch = e.touches[0];
            const rect = touchItem.getBoundingClientRect();
            touchOffset.x = touch.clientX - rect.left;
            touchOffset.y = touch.clientY - rect.top;

            // Create a simplified clone for better performance
            touchClone = touchItem.cloneNode(true);
            touchClone.style.position = 'fixed';
            touchClone.style.zIndex = '1001';
            touchClone.style.pointerEvents = 'none';
            touchClone.classList.add('dragging');
            touchClone.style.transition = 'none'; // Disable transitions for smooth dragging
            touchClone.style.left = (touch.clientX - touchOffset.x) + 'px';
            touchClone.style.top = (touch.clientY - touchOffset.y) + 'px';
            touchClone.style.opacity = '0.9';
            document.body.appendChild(touchClone);

            // Highlight the original piece
            touchItem.style.opacity = '0.4';
            touchItem.style.transform = 'scale(0.95)';

            e.preventDefault();
        }

        let lastHighlightedSlot = null; // Track last highlighted slot to avoid DOM thrashing

        function handleTouchMove(e) {
            if (!touchClone || !touchActive) return;

            e.preventDefault();

            // Use requestAnimationFrame for better performance with throttling
            if (!this.touchMoveRAF) {
                this.touchMoveRAF = requestAnimationFrame(() => {
                    const touch = e.touches[0];

                    // Update clone position with transform for better performance
                    touchClone.style.transform = `translate(${touch.clientX - touchOffset.x}px, ${touch.clientY - touchOffset.y}px)`;

                    // Optimized slot highlighting - only query DOM when needed
                    const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
                    const slot = elementBelow?.closest('.puzzle-slot');

                    // Only update if slot changed and is valid
                    if (slot !== lastHighlightedSlot) {
                        // Remove highlight from previous slot
                        if (lastHighlightedSlot && lastHighlightedSlot.classList.contains('drag-over')) {
                            lastHighlightedSlot.classList.remove('drag-over');
                        }

                        // Add highlight to new slot if it's empty
                        if (slot && !slot.querySelector('.puzzle-piece')) {
                            slot.classList.add('drag-over');
                            lastHighlightedSlot = slot;
                        } else {
                            lastHighlightedSlot = null;
                        }
                    }

                    this.touchMoveRAF = null;
                });
            }
        }

        function handleTouchEnd(e) {
            if (!touchItem || !touchClone || !touchActive) return;

            touchActive = false;

            // Cancel any pending animation frame
            if (this.touchMoveRAF) {
                cancelAnimationFrame(this.touchMoveRAF);
                this.touchMoveRAF = null;
            }

            const touch = e.changedTouches[0];
            const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
            const slot = elementBelow?.closest('.puzzle-slot');

            // Clean up highlights efficiently - only clean the last highlighted slot
            if (lastHighlightedSlot && lastHighlightedSlot.classList.contains('drag-over')) {
                lastHighlightedSlot.classList.remove('drag-over');
            }
            lastHighlightedSlot = null;

            if (slot && !slot.querySelector('.puzzle-piece')) {
                placePiece(touchItem, slot);
            } else {
                // Animate original piece back to place with transition
                touchItem.style.transition = 'all 0.3s ease';
                touchItem.style.opacity = '';
                touchItem.style.transform = '';

                // Remove transition after animation
                setTimeout(() => {
                    if (touchItem) touchItem.style.transition = '';
                }, 300);
            }

            // Clean up clone efficiently
            if (touchClone && touchClone.parentNode) {
                touchClone.parentNode.removeChild(touchClone);
            }

            // Reset all touch state
            touchClone = null;
            touchItem = null;
            touchOffset = {x: 0, y: 0};

            e.preventDefault();
        }

        // Place piece in slot
        function placePiece(piece, slot) {
            const slotIndex = parseInt(slot.dataset.index);
            const pieceIndex = parseInt(piece.dataset.index);

            // Manter tamanho original da pe√ßa, apenas ajustar para caber no slot
            piece.style.width = '100%';
            piece.style.height = '100%';
            piece.style.display = 'block';
            piece.style.margin = '0';

            slot.appendChild(piece);
            slot.classList.add('filled');
            slot.style.background = 'transparent';
            slot.style.border = 'none';
            piece.draggable = false;

            // Remove touch event listeners
            piece.removeEventListener('touchstart', handleTouchStart);
            piece.removeEventListener('touchmove', handleTouchMove);
            piece.removeEventListener('touchend', handleTouchEnd);

            gameState.completedSlots++;

            // Check if piece is in correct position
            if (slotIndex === pieceIndex) {
                piece.style.border = '2px solid #27ae60';
                piece.style.boxShadow = '0 2px 10px rgba(39, 174, 96, 0.5)';
                gameState.score += Math.floor(difficultyConfig[gameState.currentDifficulty].score / gameState.slots.length);
                updateScore();

                // Check if puzzle is complete
                if (gameState.completedSlots === gameState.slots.length) {
                    setTimeout(() => completePuzzle(), 500);
                }
            } else {
                piece.style.border = '2px solid #e74c3c';
                piece.style.opacity = '0.8';
            }
        }

        // Complete puzzle
        function completePuzzle() {
            const config = difficultyConfig[gameState.currentDifficulty];
            gameState.score += config.score;
            updateScore();

            const currentImageData = imageSequence[gameState.currentImageIndex];
            const isLastPuzzle = isGameComplete();

            const modal = document.getElementById('completeModal');
            const modalText = document.getElementById('modalText');

            document.querySelector('.modal-title').textContent = currentImageData.title;

            let buttonText = isLastPuzzle ? 'Finalizar Jogo' : 'Pr√≥ximo Ecossistema';

            modalText.innerHTML = `
                <div style="text-align: center; margin-bottom: 15px;">
                    <h3 style="color: #2c3e50; margin-bottom: 10px;">
                        ${currentImageData.ecosystem}
                    </h3>
                    <p>${currentImageData.text}</p>
                </div>
                <div style="border-top: 1px solid #ddd; padding-top: 15px; margin-top: 15px;">
                    <p><strong>üèÜ Pontos ganhos:</strong> +${config.score}</p>
                    <p><strong>üìä Pontua√ß√£o total:</strong> ${gameState.score} pontos</p>
                    <p><strong>üìà Progresso:</strong> ${gameState.currentImageIndex + 1} / ${imageSequence.length} ecossistemas</p>
                </div>
            `;

            // Update modal buttons based on whether this is the last puzzle
            document.getElementById('modalButtons').innerHTML = `
                <button class="control-btn" onclick="nextPuzzle()">${buttonText}</button>
                <button class="control-btn" onclick="backToMenu()">Menu</button>
            `;

            modal.style.display = 'flex';
        }

        // Show hint
        function showHint() {
            const unfilledPieces = document.querySelectorAll('.pieces-area .puzzle-piece');
            if (unfilledPieces.length > 0) {
                const randomPiece = unfilledPieces[Math.floor(Math.random() * unfilledPieces.length)];
                const correctSlot = document.querySelector(`.puzzle-slot[data-index="${randomPiece.dataset.index}"]:not(.filled)`);

                if (correctSlot) {
                    randomPiece.style.border = '3px solid #e74c3c';
                    correctSlot.style.border = '3px solid #e74c3c';

                    setTimeout(() => {
                        randomPiece.style.border = '2px solid rgba(0, 0, 0, 0.3)';
                        correctSlot.style.border = '2px dashed rgba(0, 0, 0, 0.2)';
                    }, 2000);
                }
            }
        }

        // Shuffle pieces
        function shufflePieces() {
            const piecesArea = document.getElementById('piecesArea');
            const pieces = Array.from(piecesArea.querySelectorAll('.puzzle-piece'));

            shuffleArray(pieces);
            piecesArea.innerHTML = '';
            pieces.forEach(piece => piecesArea.appendChild(piece));
        }

        // Show comparison
        function showComparison() {
            const currentImageData = imageSequence[gameState.currentImageIndex];
            const oppositeIndex = currentImageData.type === 'healthy' ?
                gameState.currentImageIndex + 1 : gameState.currentImageIndex - 1;

            if (oppositeIndex >= 0 && oppositeIndex < imageSequence.length) {
                const oppositeImageData = imageSequence[oppositeIndex];
                const oppositeType = oppositeImageData.type === 'healthy' ? 'saud√°vel' : 'degradado';

                const modal = document.getElementById('completeModal');
                document.querySelector('.modal-title').textContent = `Compara√ß√£o - Ecossistema ${oppositeType}`;
                document.getElementById('modalText').innerHTML = `
                    <img src="${oppositeImageData.src}" style="max-width: 100%; height: auto; border-radius: 10px; margin-bottom: 15px;">
                    <p>Esta √© a vers√£o ${oppositeType} do ecossistema <strong>${oppositeImageData.ecosystem}</strong>.</p>
                    <p>${oppositeImageData.text}</p>
                `;

                modal.style.display = 'flex';
            }
        }

        // Check if game is complete
        function isGameComplete() {
            return gameState.currentImageIndex >= imageSequence.length - 1;
        }

        // Next puzzle - linear progression
        function nextPuzzle() {
            document.getElementById('completeModal').style.display = 'none';

            if (isGameComplete()) {
                endGame();
            } else {
                gameState.currentImageIndex++;
                loadPuzzle();
            }
        }

        // End game - final completion
        function endGame() {
            gameState.isGameComplete = true;

            const modal = document.getElementById('completeModal');
            document.querySelector('.modal-title').textContent = 'üéâ Parab√©ns! Jogo Conclu√≠do!';

            document.getElementById('modalText').innerHTML = `
                <div style="text-align: center; margin-bottom: 20px;">
                    <div style="font-size: 3em; margin-bottom: 15px;">üèÜ</div>
                    <h3 style="color: #27ae60; margin-bottom: 15px;">Voc√™ explorou todos os ecossistemas!</h3>
                </div>
                <p style="margin-bottom: 15px;"><strong>üåä Ecossistemas explorados:</strong></p>
                <ul style="text-align: left; margin-bottom: 20px;">
                    <li>ü™∏ Recife de Coral (saud√°vel e amea√ßado)</li>
                    <li>üê† Vida Marinha (saud√°vel e amea√ßada)</li>
                    <li>üåä Oceano Aberto (saud√°vel e amea√ßado)</li>
                </ul>
                <p style="font-style: italic; color: #2c3e50; margin-bottom: 20px;">
                    Agora voc√™ entende melhor a import√¢ncia de proteger nossos oceanos.
                    Cada pequena a√ß√£o faz a diferen√ßa na preserva√ß√£o dos ecossistemas marinhos de Arraial do Cabo!
                </p>
                <p><strong>Pontua√ß√£o final:</strong> ${gameState.score} pontos</p>
            `;

            // Update modal buttons for final completion
            document.getElementById('modalButtons').innerHTML = `
                <button class="control-btn" onclick="playAgain()">üîÑ Jogar Novamente</button>
                <button class="control-btn" onclick="backToMenu()">üìã Menu Principal</button>
            `;

            modal.style.display = 'flex';
        }

        // Play again
        function playAgain() {
            gameState.currentImageIndex = 0;
            gameState.isGameComplete = false;
            gameState.score = 0;
            updateScore();
            document.getElementById('completeModal').style.display = 'none';

            // Reset modal buttons to default
            document.getElementById('modalButtons').innerHTML = `
                <button class="control-btn" onclick="nextPuzzle()">Pr√≥ximo</button>
                <button class="control-btn" onclick="backToMenu()">Menu</button>
            `;

            loadPuzzle();
        }

        // Back to menu
        function backToMenu() {
            // If on difficulty selection screen, go back to index.html
            const menuScreen = document.getElementById('menuScreen');
            const gameScreen = document.getElementById('gameScreen');
            const completeModal = document.getElementById('completeModal');

            // Check if we're on the difficulty selection screen
            if (menuScreen && menuScreen.style.display !== 'none' &&
                (!gameScreen || gameScreen.style.display === 'none')) {
                // On difficulty selection - go back to main game selection page
                window.location.href = 'index.html';
            } else {
                // In game - go back to difficulty selection
                if (gameScreen) gameScreen.style.display = 'none';
                if (menuScreen) menuScreen.style.display = 'flex';
                if (completeModal) completeModal.style.display = 'none';
            }
        }

        // Update score display
        function updateScore() {
            document.getElementById('score').textContent = gameState.score;
        }

        // Utility function to shuffle array
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // Handle window resize events
        window.addEventListener('resize', function() {
            if (gameState.currentDifficulty && gameState.pieces.length > 0) {
                // Recalculate layout when window resizes
                setTimeout(() => {
                    loadPuzzle();
                }, 300); // Debounce resize events
            }
        });

        // Initialize when page loads
        window.onload = function() {
            initGame();
            // Verificar se as imagens existem
            verifyImages();
            // Validar configura√ß√µes do jogo
            validateGameConfig();
        };

        // Run layout tests when puzzle loads
        const originalLoadPuzzle = window.loadPuzzle;
        window.loadPuzzle = function() {
            const result = originalLoadPuzzle.apply(this, arguments);
            setTimeout(() => {
                testLayoutDimensions();
                testVisualGuide();
            }, 100);
            return result;
        };

        /* ==================== FUTURE IMPLEMENTATION NOTES ====================
         *
         * ROADMAP FOR UNIQUE PUZZLE PIECES (PHASE 3):
         *
         * 1. SHAPE GENERATION ALGORITHM:
         *    - Create tabs and blanks using SVG paths
         *    - Generate unique edge patterns for each piece
         *    - Ensure mathematical compatibility between adjacent pieces
         *
         * 2. COLLISION DETECTION:
         *    - Implement proximity detection for piece placement
         *    - Add snap-to-place functionality with tolerance
         *    - Validate piece shape matches slot shape
         *
         * 3. CANVAS MASKING:
         *    - Use canvas clipping for complex piece shapes
         *    - Create masks for tabs and blanks
         *    - Apply anti-aliasing for smooth edges
         *
         * 4. ENHANCED PHYSICS:
         *    - Add rotation functionality (90¬∞, 180¬∞, 270¬∞)
         *    - Implement piece rotation validation
         *    - Add magnetic snap effects
         *
         * 5. CURRENT GABARITO SYSTEM:
         *    - Background guides provide immediate visual feedback
         *    - Translucent opacity (0.3) balances guidance vs challenge
         *    - Maintains educational focus over puzzle complexity
         *
         * ==================== END FUTURE NOTES ==================== */

        // Verify if images exist
        function verifyImages() {
            images.forEach((image, index) => {
                const healthyImg = new Image();
                const degradedImg = new Image();

                healthyImg.onerror = function() {
                    console.error('Healthy image not found:', image.healthy);
                };

                degradedImg.onerror = function() {
                    console.error('Degraded image not found:', image.degraded);
                };

                healthyImg.src = image.healthy;
                degradedImg.src = image.degraded;
            });
        }

        // Validate game configuration
        function validateGameConfig() {
            console.log('Validating game configuration...');

            Object.entries(difficultyConfig).forEach(([level, config]) => {
                const totalPieces = config.rows * config.cols;
                console.log(`${level}: ${config.rows}x${config.cols} = ${totalPieces} pieces`);
            });

            console.log('Images available:', images.length);
            console.log('Game configuration validated successfully!');
        }

        // Test visual guide functionality
        function testVisualGuide() {
            console.log('Testing visual guide functionality...');

            // Check if slots have background guides
            const slots = document.querySelectorAll('.puzzle-slot');
            let slotsWithGuides = 0;

            slots.forEach((slot, index) => {
                const bgImage = slot.style.backgroundImage;
                if (bgImage && bgImage !== 'none') {
                    slotsWithGuides++;
                }
            });

            console.log(`Slots with visual guides: ${slotsWithGuides}/${slots.length}`);

            if (slotsWithGuides === slots.length) {
                console.log('‚úÖ Visual guides are working correctly!');
            } else {
                console.log('‚ùå Some visual guides are missing.');
            }
        }

        // Test layout dimensions across all levels
        function testLayoutDimensions() {
            console.log('Testing PERFECT layout dimensions...');

            const board = document.querySelector('.puzzle-board');
            const piecesArea = document.querySelector('.pieces-area');
            const container = document.querySelector('.puzzle-container');

            if (board && piecesArea) {
                const boardWidth = board.offsetWidth;
                const piecesWidth = piecesArea.offsetWidth;
                const containerWidth = container.offsetWidth;

                console.log(`üìè Container width: ${containerWidth}px`);
                console.log(`üéØ Board width: ${boardWidth}px`);
                console.log(`üß© Pieces area width: ${piecesWidth}px`);
                console.log(`üìê Ratio (pieces/board): ${(piecesWidth/boardWidth).toFixed(3)}`);

                // Check if areas are perfectly equal
                const ratio = piecesWidth / boardWidth;
                if (ratio >= 0.99 && ratio <= 1.01) {
                    console.log('üéâ PERFECT! Layout areas are identical!');
                } else {
                    console.log('‚ö†Ô∏è Layout areas have minor differences.');
                }

                // Test grid templates
                const boardGridCols = board.style.gridTemplateColumns;
                const piecesGridCols = piecesArea.style.gridTemplateColumns;
                const boardGridRows = board.style.gridTemplateRows;
                const piecesGridRows = piecesArea.style.gridTemplateRows;

                console.log(`üéØ Board grid: ${boardGridCols} √ó ${boardGridRows}`);
                console.log(`üß© Pieces grid: ${piecesGridCols} √ó ${piecesGridRows}`);

                if (boardGridCols === piecesGridCols && boardGridRows === piecesGridRows) {
                    console.log('üéâ PERFECT! Grid templates are identical!');
                } else {
                    console.log('‚ö†Ô∏è Grid templates might not match.');
                }

                // Test piece-to-slot size correspondence
                const slots = document.querySelectorAll('.puzzle-slot');
                const pieces = document.querySelectorAll('.puzzle-piece');

                if (slots.length > 0 && pieces.length > 0) {
                    const firstSlot = slots[0];
                    const firstPiece = pieces[0];
                    const slotWidth = firstSlot.offsetWidth;
                    const pieceWidth = firstPiece.offsetWidth;

                    console.log(`üéØ First slot width: ${slotWidth}px`);
                    console.log(`üß© First piece width: ${pieceWidth}px`);
                    console.log(`üìè Piece-to-slot ratio: ${(pieceWidth/slotWidth).toFixed(3)}`);

                    const pieceSlotRatio = pieceWidth / slotWidth;
                    if (pieceSlotRatio >= 0.95 && pieceSlotRatio <= 1.05) {
                        console.log('üéâ PERFECT! Pieces match slot sizes exactly!');
                    } else {
                        console.log('‚ö†Ô∏è Pieces and slots might have size differences.');
                    }

                    console.log(`üìä Total slots: ${slots.length}, Total pieces: ${pieces.length}`);
                    console.log(`üéØ Current difficulty: ${gameState.currentDifficulty || 'Not started'}`);
                }
            }
        }
    </script>
</body>
</html>